name: Create Review App
on:
  pull_request:
    types: [opened]

env:
  ECR_REPO: fleet-ecr
  PROJECT: APP_NAME # request-bin
  SERVER_PATH: APP_SERVER_PATH # server/
  SQL_FILE: DB_SETUP_PATH # server/db/migration.sql
  BUILDER: CNBP_BUILDER # paketobuildpacks/builder:base
  DB_NAME: DATABASE_NAME # request_bin
  SUBNET_NAME: DEFAULT_SUBNET_NAME # Fleet-Subnet
  SG_NAME: CLUSTER_SECURITY_GROUP # Fleet-Security-3
  FS_TOKEN: EFS_CREATION_TOKEN # FleetFS
  REGION: USER_AWS_REGION # us-east-2
  PR_NUMBER: ${{ github.event.pull_request.number }}

#   teardown:
#     runs-on: ubuntu-20.04
#     steps:
#       - name: Delete from ECR
#         if: ${{ github.event.pull_request }}
# tag: project-pr#, project-seed-pr#
# - name: Deregister task definition
# if: (synchronize, close)
# - name: Stop ECS Service
# if: (synchronize, close)
# - name: Clear EFS
# if: (synchronize, close)

jobs:
  build:
    runs-on: ubuntu-20.04
    steps:
      - name: Checkout Code
        uses: actions/checkout@v1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Install Pack CLI
        id: install-pack
        run: |
          sudo add-apt-repository ppa:cncf-buildpacks/pack-cli && \
          sudo apt-get update && \
          sudo apt-get install pack-cli

      #This step will do six things:
      # 1. set the server image arn environment variable
      # 2. set the seeder image arn environment variable
      # 3. Set Subnet ID environment variable
      # 4. Set Security Group ID Environment Variable
      # 5. Get the Task Execution Role Arn and set it to an environment variable
      # 6. Get the fs-id of our EFS and set it to an environment variable
      - name: set required environment variables
        id: aws-ids
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          echo "::set-output name=image-arn::$ECR_REGISTRY/$ECR_REPO:$PROJECT-$PR_NUMBER"
          echo "::set-output name=seed-arn::$ECR_REGISTRY/$ECR_REPO:$PROJECT-seed-$PR_NUMBER"
          echo "::set-output name=subnet-id::$( \
            aws ec2 describe-subnets \
              --filters Name=tag:Name,Values=$SUBNET_NAME \
              --query 'Subnets[0].SubnetId' \
              --output text)"
          echo "::set-output name=sg-id::$( \
            aws ec2 describe-security-groups \
              --filters Name=group-name,Values=$SG_NAME \
              --query 'SecurityGroups[0].GroupId' \
              --output text)"
          echo "::set-output name=task-execution-role-arn::$( \
            aws iam get-role \
              --role-name fleetTaskExecutionRole \
              --query 'Role.Arn' \
              --output text)"
          echo "::set-output name=efs-id::$( \
            aws efs describe-file-systems \
              --creation-token $FS_TOKEN \
              --query 'FileSystems[0].FileSystemId' \
              --output text)"

        #TODO: New step: Pull the google builder & cache?
      - name: build, tag, and push image using Cloud Native Builder
        id: build-server
        run: | # --cache-image $ECR_REGISTRY/$ECR_REPO:cache \
          pack build ${{ steps.aws-ids.outputs.image-arn }} \
          --builder $BUILDER \
          --path $SERVER_PATH \
          --publish

      - name: Create image for SQL Seeder
        id: make-sql-seeder
        run: |
          cat << SCRIPT > ./seeder-script.sh
          #!/bin/sh
          mv ./init.sql ./efs-file-transfer/
          ls ./efs-file-transfer/
          SCRIPT

          docker build -t ${{ steps.aws-ids.outputs.seed-arn }} -f- .  <<EOF
          FROM alpine:3.13
          COPY $SQL_FILE init.sql
          COPY ./seeder-script /startup.sh
          RUN chmod +x /startup.sh
          RUN mkdir efs-file-transfer
          ENTRYPOINT ["/startup.sh"]
          EOF

      - name: Push image for SQL Seeder to ECR
        id: push-seed
        run: |
          docker push ${{ steps.aws-ids.outputs.seed-arn }}

      - name: write task definition for image
        id: task-gen
        uses: Mush-Framework/create-task-definition@v0.3.3
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        with:
          server-arn: ${{ steps.aws-ids.outputs.image-arn }}
          seed-arn: ${{ steps.aws-ids.outputs.seed-arn }}
          db-name: ${{ env.DB_NAME }}
          efs-id: ${{ steps.aws-ids.outputs.efs-id }}
          app-name: ${{ env.PROJECT }}
          task-execution-role-arn: ${{ steps.aws-ids.outputs.task-execution-role-arn }}
          region: ${{ env.REGION }}
          pr-number: ${{ env.PR_NUMBER}}

      - name: write task definition to file.
        run: |
          echo '${{ steps.task-gen.outputs.seeder-task-definition }}' > ./seed-task.json && \
          echo '${{ steps.task-gen.outputs.service-task-definition }}' > ./app-task.json

      - name: register task definition of seeder.
        id: seed-task-def
        run: |
          echo "::set-output name=seed-def::$(aws ecs register-task-definition \
          --family $PROJECT-setup-$PR_NUMBER \
          --cli-input-json file://seed-task.json \
          --query 'join(`:`,taskDefinition.[family,to_string(revision)])' \
          --output text)"

      - name: register task definition of review app.
        id: app-task-def
        run: |
          echo "::set-output name=app-def::$(aws ecs register-task-definition \
           --family $PROJECT-$PR_NUMBER \
           --cli-input-json file://app-task.json \
           --query 'join(`:`,taskDefinition.[family,to_string(revision)])' \
           --output text)"

      - name: verify the names of the task definitions.
        run: |
          echo ${{ steps.app-task-def.outputs.app-def }}, ${{  steps.seed-task-def.outputs.seed-def }}

      - name: Launch the seeder task.
        id: launch-seed-task
        run: |
          echo "::set-output name=task-arn::$(aws ecs run-task \
            --cluster $PROJECT \
            --task-definition ${{ steps.seed-task-def.outputs.seed-def }} \
            --count 1 \
            --launch-type "FARGATE" \
            --network-configuration "awsvpcConfiguration={ \
                subnets=[${{ steps.aws-ids.outputs.subnet-id }}], \
                securityGroups=[${{ steps.aws-ids.outputs.sg-id }}], \
                assignPublicIp=ENABLED \
              }" \
            --query 'tasks[0].taskArn' \
            --output text)"

      - name: Wait until the seed task completes.
        run: |
          aws ecs wait tasks-stopped --cluster $PROJECT --tasks ${{ steps.launch-seed-task.outputs.task-arn }}

      - name: Launch the app service.
        run: |
          echo "::set-output name=service-arn::$(aws ecs create-service \
            --cluster $PROJECT \
            --service-name $PROJECT-$PR_NUMBER-$GITHUB_SHA \
            --task-definition ${{ steps.app-task-def.outputs.app-def }} \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={ \
                subnets=[${{ steps.aws-ids.outputs.subnet-id }}], \
                securityGroups=[${{ steps.aws-ids.outputs.sg-id }}], \
                assignPublicIp=ENABLED \
              }" \
            --query 'service.serviceArn' \
            --output text)"

      - name: Wait until the app service is stable.
        run: |
          aws ecs wait services-stable \
            --cluster $PROJECT \
            --services $PROJECT-$PR_NUMBER-$GITHUB_SHA

      - name: Get public address of service.
        id: get-public-url
        run: |
          TASK_ID=$(aws ecs list-tasks \
            --cluster $PROJECT \
            --service-name $PROJECT-$PR_NUMBER-$GITHUB_SHA \
            --query 'taskArns | [0]' \
            --output text | grep -o "[^/]*$")

          INTERFACE_ID=$(aws ecs describe-tasks \
            --cluster $PROJECT \
            --tasks $TASK_ID \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value | [0]' \
            --output text)

          echo "::set-output name=public-url::$(aws ec2 describe-network-interfaces \
          --network-interface-ids $INTERFACE_ID \
          --query 'NetworkInterfaces[0].Association.PublicDnsName' \
          --output text)"

      - name: "Comment On PR"
        uses: actions/github-script@v3
        if: github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { 
              issue: { 
                number: issue_number 
              },
              repo: { 
                owner, 
                repo
              }
            } = context;
            github.issues.createComment({
              issue_number,
              owner,
              repo,
              body: 'Check out the preview here http://${{ steps.get-public-url.outputs.public-url }}' 
            });
